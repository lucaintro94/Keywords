# -*- coding: utf-8 -*-
"""keywords.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14AGRUj37b8k9x00pw7VLt8JdOAnUktOA

# **LITERATURE REVIEW KEYWORDS-BASED**
---
### D'Andrea Luca
Python Driving License - June 2023

## Summary

The following code has been wrtitten to obtain the scientific papers starting from a database (i.e. from scopus). The user can choose different keywords to filter the results. A further filter on the year of pubblication can be used. The title and the year of pubblication can be exported as a txt file. In the last part of the code, some graph reproduce the results of the research.

## Part 1
Import of the database. The initial database has been created starting from two keywords: "glass scaffold" and "ceramic scaffold".
"""

# Commented out IPython magic to ensure Python compatibility.
# import of the initial database from the drive folder
from google.colab import drive
drive.mount('/content/drive')

# change directory
# %cd /content/drive/MyDrive/Colab Notebooks
# %ls

# import of the python libraries
import numpy  as np
import pandas as pd

# be sure the file exists in the current directory
filename = 'scopus.xlsx'
#filename = 'linda.xlsx'
data = pd.read_excel(filename)

dimensioni = np.shape(data)

# check the dimensions of the database
print(dimensioni)

"""## Part 2
The user select the keywords and apply a filter year-based. For each combination a file with the name of the keywords is written.
"""

from itertools import combinations_with_replacement as comb
from collections import Counter
import matplotlib.pyplot as plt
import math
import numpy  as np
import pandas as pd

# insert the keywords: 'mech', 'biol', 'mech', 'finite element'
par1 = 'elastic'
par2 = 'young'
par3 = 'strength'
par4 = 'fracture'
par5 = 'finite element'
i3 = 2000

strings = [par1, par2, par3, par4, par5]

# Generate combinations
comb_list = list(comb(strings, 2))
taglia = np.shape(comb_list)
taglia2 = taglia[0]
vector_data = []
annov = []


# Convert the combinations into a matrix of strings
matrix_of_strings = [list(combo) for combo in comb_list]

# Print the combinations
for combo2 in range(taglia2):
    print(combo2)

    pat0 = comb_list[combo2]
    print(pat0)
    pat1 = pat0[0]
    pat2 = pat0[1]

    howmany = 0

    df = pd.DataFrame(data)
    dime = np.shape(data)

    annostr = data['Year']
    annostr2 = annostr[1:]
    titlestr = data['Title']
    titlestr2 = titlestr[1:]

    annonum = [int(element) for element in annostr2]
    linelist = []

    for line in range(dime[0]):
        i1 = 0
        i2 = 0
        for col in range(dime[1]):
            TF1 = pat1.lower() in str(df.iloc[line, col]).lower()
            TF2 = pat2.lower() in str(df.iloc[line, col]).lower()
            if TF1:
                i1 = 1
            if TF2:
                i2 = 1

        if i1 == 1 and i2 == 1 and annonum[line]>= i3:
            howmany += 1
            linelist.append(line)

    print(f'howmany: {howmany}')
    vector_data.append(howmany)


    # Stampo la posizione dei vettori
    # print(f'linelist: {linelist}')

    file_path = pat1 + "_" + pat2 + ".txt"

    annov = [0] * howmany
    with open(file_path, 'a') as file:
      for ii in range(howmany):
        tt = linelist[ii]
        titolo = data['Title'].iloc[tt]
        anno = data['Year'].iloc[tt]
        annov[ii] = anno
        titolist = titolo.split()

        matrix = str(anno) + " " + titolo

        #print(matrix)
        #file.write(matrix + '\n')

    if howmany > 0:
        year_counts = Counter(annov)
        # Convert the Counter to a dictionary if needed
        year_counts_dict = dict(year_counts)
        # Extract the items and their counts from the counter
        items, counts = zip(*year_counts.items())
        # Create a bar plot for the counter variable
        plt.figure()
        plt.title(pat1 + "_" + pat2)
        plt.bar(items, counts)
#        integer_ticks = np.arange(i3, , 1)  # Adjust the range and step as needed
#        plt.xticks(integer_ticks)



# Print the bars of all papers
year_counts2 = Counter(data['Year'])
# Convert the Counter to a dictionary if needed
year_counts_dict2 = dict(year_counts2)
# Extract the items and their counts from the counter
items2, counts2 = zip(*year_counts2.items())
# Create a bar plot for the counter variable
plt.figure()
plt.bar(items2, counts2)
plt.title("Glass and Ceramic Scaffolds")

"""## Part 3
Since the analyzed problem is characterized by a multidisciplinary approach, some plots help to visualize the multidisciplinarity of the problem.

The first graph represents the numeber of studies that couple at least two research fields.
"""

import matplotlib.pyplot as plt
import math

# Data from previous section
# Calculate the size of the square matrix

SS = np.shape(vector_data)

# Transform the tuple into number
concatenated_string = ''.join(map(str, SS))
S = int(concatenated_string)

# Function to compute the number of terms (n) given a sum (S)
def inverse_gaussian_sum(S):
    n = (-1 + math.sqrt(1 + 8 * S))/2
    return int(n)

n = inverse_gaussian_sum(S)
# Create a symmetric matrix from the vector
symmetric_matrix = np.zeros((n, n))
k = 0
for i in range(n):
    for j in range(i, n):
        symmetric_matrix[i, j] = vector_data[k]
        symmetric_matrix[j, i] = symmetric_matrix[i, j]
        k += 1

# Create a 2D histogram
plt.imshow(symmetric_matrix, cmap='viridis', interpolation='nearest')
plt.colorbar()

# Display the values in the middle of each box
for i in range(len(strings)):
    for j in range(len(strings)):
        plt.text(j, i, str(int(symmetric_matrix[i, j])), ha='center', va='center', color='white')

# Set row and column labels
plt.xticks(np.arange(len(strings)), strings)
plt.yticks(np.arange(len(strings)), strings)

# plot labels in vertical axis from bottom to top
plt.gca().invert_yaxis()

# Rotate the y-axis labels to display them diagonally
plt.xticks(rotation=45)
plt.yticks(rotation=45)

titolo_graf = 'Table of combinations from ' + str(i3)
plt.title(titolo_graf)

# Show the plot
plt.show()